{% extends 'layouts/default/page.html' %}

{% block extra_style %}
<style>
    .chat-container {
        display: flex;
        height: calc(100vh - 56px); /* Subtract navbar height */
        overflow: hidden;
    }

    /* Clients List */
    .clients-sidebar {
        width: 300px;
        min-width: 300px;
        border-right: 1px solid #e0e0e0;
        display: flex;
        flex-direction: column;
        background: #f8f9fa;
        height: calc(100vh - 75px)
    }

    .clients-header {
        padding: 20px;
        background: #fff;
        border-bottom: 1px solid #e0e0e0;
        font-size: 18px;
        font-weight: 600;
    }

    .clients-list {
        flex: 1;
        overflow-y: auto;
        min-height: 0;
    }

    .clients-list a {
        text-decoration: none;
        color: inherit;
        display: block;
    }

    .client-item {
        padding: 15px 20px;
        border-bottom: 1px solid #e0e0e0;
        cursor: pointer;
        transition: background 0.2s;
        background: #fff;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .client-item:hover {
        background: #f0f0f0;
    }

    .client-item.active {
        background: #e3f2fd;
        border-left: 3px solid #2196F3;
    }

    .client-item.has-unread {
        font-weight: 600;
    }

    .client-name {
        flex: 1;
    }

    .unread-badge {
        background: #2196F3;
        color: white;
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 12px;
        font-weight: 600;
        min-width: 20px;
        text-align: center;
    }

    /* Chat Area */
    .chat-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: #fff;
    }

    .empty-state {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #999;
        font-size: 16px;
    }

    @keyframes highlight {
        0%, 100% { background: transparent; }
        50% { background: #ffeb3b; }
    }

    .hidden {
        display: none;
    }

    .container-fluid {
        padding: 0;
        margin: 0;
        max-width: 100%;
    }
</style>

{% block chat_extra_style %}
{% endblock chat_extra_style %}

{% endblock extra_style %}


{% block content %}
<div class="chat-container">
    <!-- Clients Sidebar -->
    <div class="clients-sidebar">
        <div class="clients-header">Clients</div>
        <div class="clients-list" id="clientsList">
            {% for client in clients %}
            <a href="#" onclick="selectClient(event, '{% url 'chat:chat_with_client' client.id %}')">
                <div class="client-item {% if client.unread_count > 0 %}has-unread{% endif %} {% if selected_client and client.id == selected_client.id %}active{% endif %}">
                    <span class="client-name">{{client.name|escape}}</span>
                    {% if client.unread_count > 0 %}<span class="unread-badge">{{ client.unread_count }}</span>{% endif %}
                </div>
            </a>
            {% endfor %}
        </div>
    </div>

    <!-- Chat Area -->
    <div class="chat-area">
        {% block chat_with_client %}
        <div id="emptyState" class="empty-state">
            Выберете клиента из списка
        </div>
        {% endblock chat_with_client %}
    </div>
</div>

<script>
    let ws = null
    let web_socket_queue = []

    // CSRF Token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    const csrftoken = getCookie('csrftoken');

    document.addEventListener('DOMContentLoaded', function() {
        connectWebSocket();
    });

    function connectWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
        ws = new WebSocket(`${protocol}//${window.location.host}/ws/chat/`)
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);

            console.log("message from server: " + event.data);
            if (data.type === 'new_message') {
                handleNewMessage(data.message)
            }
        }
        ws.onopen = () => {
            while (typeof (item = web_socket_queue.shift()) !== "undefined") {
                ws.send(item);
            }
        }
        ws.onerror = (event) => {
            console.log('WebSocket error: ' + event);
        }
        ws.onclose = (event) => {
            console.log('WebSocket disconnected. Reconnecting...');
            setTimeout(() => connectWebSocket(), 3000);
        }
    }

    function selectClient(e, chatWithClientUrl) {
        e.preventDefault();
        window.location.href = chatWithClientUrl;
    }

    function mark_read(client_id) {
        sendToWS({
            action: 'mark_read',
            client_id: client_id
        });
    }

    function sendToWS(message) {
        try {
            stringified = JSON.stringify(message);
            if (ws && ws.readyState == WebSocket.OPEN) {
                ws.send(stringified);
            } else {
                web_socket_queue.push(stringified)
            }
            return true;
        } catch (error) {
            console.error("Error sending message: ", error);
            return false;
        }
    }
</script>

{% block chat_extra_js %}
{% endblock chat_extra_js %}

{% endblock content %}

<script>

    // Handle new message
    function handleNewMessage(message) {
        // Update client list
        const client = clients.find(c => c.id === message.client_id);
        if (client) {
            if (!message.is_manager && (!selectedClient || selectedClient.id !== message.client_id)) {
                client.unread_count++;
            }
            client.last_message_time = message.created;
            renderClients();
        }

        // Add message to chat if this client is selected
        if (selectedClient && selectedClient.id === message.client_id) {
            messages.push(message);
            const messageElement = createMessageElement(message);
            document.getElementById('messagesContainer').appendChild(messageElement);
            scrollToBottom();
        }
    }

    // Handle message edited
    function handleMessageEdited(message) {
        if (selectedClient && selectedClient.id === message.client_id) {
            const index = messages.findIndex(m => m.id === message.id);
            if (index !== -1) {
                messages[index].text = message.text;
                renderMessages();
            }
        }
    }

    // Handle message deleted
    function handleMessageDeleted(messageId, clientId) {
        if (selectedClient && selectedClient.id === clientId) {
            const index = messages.findIndex(m => m.id === messageId);
            if (index !== -1) {
                messages.splice(index, 1);
                renderMessages();
            }
        }
    }

    // Handle messages read
    function handleMessagesRead(clientId) {
        const client = clients.find(c => c.id === clientId);
        if (client) {
            client.unread_count = 0;
            renderClients();
        }
    }
    // Send message
    async function sendMessage() {
        const messageInput = document.getElementById('messageInput');
        const messageText = messageInput.value.trim();

        if (!messageText || !selectedClient) return;

        try {
            if (editingMessage) {
                // Edit existing message
                const response = await fetch('/chat/api/edit/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify({
                        message_id: editingMessage.id,
                        text: messageText
                    })
                });

                const data = await response.json();
                if (data.success) {
                    messageInput.value = '';
                    cancelEdit();
                }
            } else {
                // Send new message
                const response = await fetch('/chat/api/send/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify({
                        client_id: selectedClient.id,
                        text: messageText,
                        reply_to_telegram_id: replyingTo ? replyingTo.telegram_id : null
                    })
                });

                const data = await response.json();
                if (data.success) {
                    messageInput.value = '';
                    cancelReply();
                }
            }
        } catch (error) {
            console.error('Error sending message:', error);
        }
    }

    // Reply to message
    function replyToMessage() {
        replyingTo = contextMenuMessage;
        document.getElementById('replyText').textContent = 'Replying to: ' + truncateText(contextMenuMessage.text, 50);
        document.getElementById('replyIndicator').classList.add('show');
        document.getElementById('messageInput').focus();
        document.getElementById('contextMenu').classList.remove('show');
    }

    // Edit message
    function editMessage() {
        editingMessage = contextMenuMessage;
        document.getElementById('messageInput').value = contextMenuMessage.text;
        document.getElementById('editIndicator').classList.add('show');
        document.getElementById('sendButton').textContent = 'Save';
        document.getElementById('messageInput').focus();
        document.getElementById('contextMenu').classList.remove('show');
    }

    // Delete message
    async function deleteMessage() {
        if (!confirm('Are you sure you want to delete this message?')) {
            return;
        }

        try {
            const response = await fetch('/chat/api/delete/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify({
                    message_id: contextMenuMessage.id
                })
            });

            const data = await response.json();
            if (data.success) {
                // Message will be removed via WebSocket
            }
        } catch (error) {
            console.error('Error deleting message:', error);
        }

        document.getElementById('contextMenu').classList.remove('show');
    }

    // Cancel reply
    function cancelReply() {
        replyingTo = null;
        document.getElementById('replyIndicator').classList.remove('show');
    }

    // Cancel edit
    function cancelEdit() {
        editingMessage = null;
        document.getElementById('messageInput').value = '';
        document.getElementById('editIndicator').classList.remove('show');
        document.getElementById('sendButton').textContent = 'Send';
    }

    // Scroll to bottom
    function scrollToBottom() {
        const container = document.getElementById('messagesContainer');
        container.scrollTop = container.scrollHeight;
    }

    // Scroll to reply message
    function scrollToReplyMessage(telegramId) {
        const messageElement = document.querySelector(`[data-telegram-id="${telegramId}"]`);
        if (messageElement) {
            messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Highlight the message temporarily
            messageElement.classList.add('highlighted');
            setTimeout(() => {
                messageElement.classList.remove('highlighted');
            }, 1000);
        }
    }

</script>