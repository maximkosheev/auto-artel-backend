{% extends 'layouts/default/page.html' %}

{% block extra_style %}
<style>
    .chat-container {
        display: flex;
        height: calc(100vh - 56px); /* Subtract navbar height */
        overflow: hidden;
    }

    /* Clients List */
    .clients-sidebar {
        width: 300px;
        min-width: 300px;
        border-right: 1px solid #e0e0e0;
        display: flex;
        flex-direction: column;
        background: #f8f9fa;
        height: calc(100vh - 75px)
    }

    .clients-header {
        padding: 20px;
        background: #fff;
        border-bottom: 1px solid #e0e0e0;
        font-size: 18px;
        font-weight: 600;
    }

    .clients-list {
        flex: 1;
        overflow-y: auto;
        min-height: 0;
    }

    .clients-list a {
        text-decoration: none;
        color: inherit;
        display: block;
    }

    .client-item {
        padding: 15px 20px;
        border-bottom: 1px solid #e0e0e0;
        cursor: pointer;
        transition: background 0.2s;
        background: #fff;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .client-item:hover {
        background: #f0f0f0;
    }

    .client-item.active {
        background: #e3f2fd;
        border-left: 3px solid #2196F3;
    }

    .client-item.has-unread {
        font-weight: 600;
    }

    .client-name {
        flex: 1;
    }

    .unread-badge {
        background: #2196F3;
        color: white;
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 12px;
        font-weight: 600;
        min-width: 20px;
        text-align: center;
    }

    /* Chat Area */
    .chat-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: #fff;
    }

    .empty-state {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #999;
        font-size: 16px;
    }

    @keyframes highlight {
        0%, 100% { background: transparent; }
        50% { background: #ffeb3b; }
    }

    .hidden {
        display: none;
    }

    .container-fluid {
        padding: 0;
        margin: 0;
        max-width: 100%;
    }
</style>

{% block chat_extra_style %}
{% endblock chat_extra_style %}

{% endblock extra_style %}


{% block content %}
<div class="chat-container">
    <!-- Clients Sidebar -->
    <div class="clients-sidebar">
        <div class="clients-header">Clients</div>
        <div class="clients-list" id="clientsList">
            {% for client in clients %}
            <a href="{% url 'chat:chat_with_client' client.id %}">
                <div class="client-item {% if client.unread_count > 0 %}has-unread{% endif %} {% if selected_client and client.id == selected_client.id %}active{% endif %}">
                    <span class="client-name">{{client.name|escape}}</span>
                    {% if client.unread_count > 0 %}<span class="unread-badge">{{ client.unread_count }}</span>{% endif %}
                </div>
            </a>
            {% endfor %}
        </div>
    </div>

    <!-- Chat Area -->
    <div class="chat-area">
        {% block chat_with_client %}
        <div id="emptyState" class="empty-state">
            Выберете клиента из списка
        </div>
        {% endblock chat_with_client %}
    </div>
</div>

<script>
// CSRF Token
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}
const csrftoken = getCookie('csrftoken');
</script>

{% block chat_extra_js %}
{% endblock chat_extra_js %}

{% endblock content %}

<script>
    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
        loadClients();
        connectWebSocket();

        // Close context menu on click outside
        document.addEventListener('click', function() {
            document.getElementById('contextMenu').classList.remove('show');
        });

        // Handle Enter key in textarea
        document.getElementById('messageInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    });

    // Load messages for selected client
    async function loadMessages(clientId) {
        try {
            const response = await fetch(`/chat/api/messages/${clientId}/`);
            const data = await response.json();
            messages = data.messages;
            renderMessages();
            scrollToBottom();
        } catch (error) {
            console.error('Error loading messages:', error);
        }
    }

    // Render messages
    function renderMessages() {
        const messagesContainer = document.getElementById('messagesContainer');
        messagesContainer.innerHTML = '';

        messages.forEach(message => {
            const messageDiv = createMessageElement(message);
            messagesContainer.appendChild(messageDiv);
        });
    }

    // Create message element
    function createMessageElement(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${message.is_manager ? 'manager-message' : 'client-message'}`;
        messageDiv.dataset.messageId = message.id;
        messageDiv.dataset.telegramId = message.telegram_id;

        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';

        // Reply quote
        if (message.reply_to_text) {
            const quoteDiv = document.createElement('div');
            quoteDiv.className = 'message-reply-quote';
            quoteDiv.textContent = truncateText(message.reply_to_text, 50);
            quoteDiv.onclick = (e) => {
                e.stopPropagation();
                scrollToReplyMessage(message.reply_to_telegram_id);
            };
            contentDiv.appendChild(quoteDiv);
        }

        // Message text
        const textDiv = document.createElement('div');
        textDiv.className = 'message-text';
        textDiv.textContent = message.text;
        contentDiv.appendChild(textDiv);

        // Media
        if (message.media && message.media.length > 0) {
            const mediaDiv = document.createElement('div');
            mediaDiv.className = 'message-media';
            message.media.forEach(mediaData => {
                const img = document.createElement('img');
                img.src = 'data:image/png;base64,' + mediaData;
                mediaDiv.appendChild(img);
            });
            contentDiv.appendChild(mediaDiv);
        }

        // Time
        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        timeDiv.textContent = formatTime(message.created);
        contentDiv.appendChild(timeDiv);

        messageDiv.appendChild(contentDiv);

        // Context menu
        messageDiv.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            showContextMenu(e, message);
        });

        return messageDiv;
    }

    // Connect WebSocket
    function connectWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(`${protocol}//${window.location.host}/ws/chat/`);

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);

            if (data.type === 'new_message') {
                handleNewMessage(data.message);
            } else if (data.type === 'message_edited') {
                handleMessageEdited(data.message);
            } else if (data.type === 'message_deleted') {
                handleMessageDeleted(data.message_id, data.client_id);
            } else if (data.type === 'messages_read') {
                handleMessagesRead(data.client_id);
            }
        };

        ws.onclose = () => {
            console.log('WebSocket disconnected. Reconnecting...');
            setTimeout(() => connectWebSocket(), 3000);
        };
    }

    // Handle new message
    function handleNewMessage(message) {
        // Update client list
        const client = clients.find(c => c.id === message.client_id);
        if (client) {
            if (!message.is_manager && (!selectedClient || selectedClient.id !== message.client_id)) {
                client.unread_count++;
            }
            client.last_message_time = message.created;
            renderClients();
        }

        // Add message to chat if this client is selected
        if (selectedClient && selectedClient.id === message.client_id) {
            messages.push(message);
            const messageElement = createMessageElement(message);
            document.getElementById('messagesContainer').appendChild(messageElement);
            scrollToBottom();
        }
    }

    // Handle message edited
    function handleMessageEdited(message) {
        if (selectedClient && selectedClient.id === message.client_id) {
            const index = messages.findIndex(m => m.id === message.id);
            if (index !== -1) {
                messages[index].text = message.text;
                renderMessages();
            }
        }
    }

    // Handle message deleted
    function handleMessageDeleted(messageId, clientId) {
        if (selectedClient && selectedClient.id === clientId) {
            const index = messages.findIndex(m => m.id === messageId);
            if (index !== -1) {
                messages.splice(index, 1);
                renderMessages();
            }
        }
    }

    // Handle messages read
    function handleMessagesRead(clientId) {
        const client = clients.find(c => c.id === clientId);
        if (client) {
            client.unread_count = 0;
            renderClients();
        }
    }
    // Send message
    async function sendMessage() {
        const messageInput = document.getElementById('messageInput');
        const messageText = messageInput.value.trim();

        if (!messageText || !selectedClient) return;

        try {
            if (editingMessage) {
                // Edit existing message
                const response = await fetch('/chat/api/edit/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify({
                        message_id: editingMessage.id,
                        text: messageText
                    })
                });

                const data = await response.json();
                if (data.success) {
                    messageInput.value = '';
                    cancelEdit();
                }
            } else {
                // Send new message
                const response = await fetch('/chat/api/send/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify({
                        client_id: selectedClient.id,
                        text: messageText,
                        reply_to_telegram_id: replyingTo ? replyingTo.telegram_id : null
                    })
                });

                const data = await response.json();
                if (data.success) {
                    messageInput.value = '';
                    cancelReply();
                }
            }
        } catch (error) {
            console.error('Error sending message:', error);
        }
    }

    // Reply to message
    function replyToMessage() {
        replyingTo = contextMenuMessage;
        document.getElementById('replyText').textContent = 'Replying to: ' + truncateText(contextMenuMessage.text, 50);
        document.getElementById('replyIndicator').classList.add('show');
        document.getElementById('messageInput').focus();
        document.getElementById('contextMenu').classList.remove('show');
    }

    // Edit message
    function editMessage() {
        editingMessage = contextMenuMessage;
        document.getElementById('messageInput').value = contextMenuMessage.text;
        document.getElementById('editIndicator').classList.add('show');
        document.getElementById('sendButton').textContent = 'Save';
        document.getElementById('messageInput').focus();
        document.getElementById('contextMenu').classList.remove('show');
    }

    // Delete message
    async function deleteMessage() {
        if (!confirm('Are you sure you want to delete this message?')) {
            return;
        }

        try {
            const response = await fetch('/chat/api/delete/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify({
                    message_id: contextMenuMessage.id
                })
            });

            const data = await response.json();
            if (data.success) {
                // Message will be removed via WebSocket
            }
        } catch (error) {
            console.error('Error deleting message:', error);
        }

        document.getElementById('contextMenu').classList.remove('show');
    }

    // Cancel reply
    function cancelReply() {
        replyingTo = null;
        document.getElementById('replyIndicator').classList.remove('show');
    }

    // Cancel edit
    function cancelEdit() {
        editingMessage = null;
        document.getElementById('messageInput').value = '';
        document.getElementById('editIndicator').classList.remove('show');
        document.getElementById('sendButton').textContent = 'Send';
    }

    // Scroll to bottom
    function scrollToBottom() {
        const container = document.getElementById('messagesContainer');
        container.scrollTop = container.scrollHeight;
    }

    // Scroll to reply message
    function scrollToReplyMessage(telegramId) {
        const messageElement = document.querySelector(`[data-telegram-id="${telegramId}"]`);
        if (messageElement) {
            messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Highlight the message temporarily
            messageElement.classList.add('highlighted');
            setTimeout(() => {
                messageElement.classList.remove('highlighted');
            }, 1000);
        }
    }

</script>